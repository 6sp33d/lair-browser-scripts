function bulkImportHosts(hostsToAdd){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var existingHosts=Hosts.find({'projectId':projectId}).fetch() hostsToAdd.forEach(function(host){var hostIp=host var service='' if(host.indexOf(':')!=-1){var parts=host.split(':') hostIp=parts[0] port=parts[1] protocol=parts[2] serviceName=parts[3] product=parts[4] if(existingHosts.includes(hostIp)){console.log(hostIp+" already exists in the project.")} var existingHost=Hosts.findOne({'projectId':projectId,'ipv4':hostIp}) if(existingHost==null){Meteor.call('createHost',projectId,hostIp,'','') console.log("Created host record for "+hostIp)} var newHost=Hosts.findOne({'projectId':projectId,'ipv4':hostIp}) if(newHost!=null){var service=Services.findOne({'projectId':projectId,'hostId':newHost._id,'port':port}) if(service!=null){console.log("Service already exists on port "+hostIp+":"+port+"/"+protocol)}else{Meteor.call('createService',projectId,newHost._id,parseInt(port),protocol,serviceName,product) console.log("Created service record for "+hostIp+":"+port+"/"+protocol)}}}else{if(existingHosts.includes(host)){console.log(host+" already exists in the project.")}else{Meteor.call('createHost',projectId,host,'','') console.log("Created host record for "+host)}}})} function bulkRemoveHosts(hostsToRemove){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var hosts=Hosts.find({'projectId':projectId}).fetch() count=0 hosts.forEach(function(host){if(hostsToRemove.includes(host.ipv4)){Meteor.call('removeHost',projectId,host._id,function(err){if(err){console.log("Error removing "+host.ipv4+". "+err)}else{Meteor.call('removeHostFromIssues',projectId,host._id)}}) count ++}}) console.log('Total of '+count+' host(s) removed.')} function changeHostsToSpecifiedColorByServicesOrIssues(servicesOrIssues,statusOption,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var statCount=0 var count=0 function allSameColor(value,index,array){if(index===0){return!0} return(value.status===array[index-1].status)} function changeHostColor(id,newColor){Hosts.update({'_id':id},{$set:{'status':newColor,'lastModifiedBy':modifiedBy}})} function getServices(id){return Services.find({'projectId':projectId,'hostId':id}).fetch()} function getIssues(id){var hostIpv4=Hosts.findOne({'_id':id}).ipv4 return Issues.find({'projectId':projectId,'hosts.ipv4':hostIpv4}).fetch()} function getServicesOrIssues(id){if(servicesOrIssues==='services'){return getServices(id)}else if(servicesOrIssues==='issues'){return getIssues(id)} throw{name:'Incorrect servicesOrIssues Selection',message:'Incorrect servicesOrIssues selection: "'+servicesOrIssues+'" is not a valid servicesOrIssues for this function'}} if(StatusMap.indexOf(lairColor)===-1){console.log('Lair Supserviceed colors: '+StatusMap) throw{name:'Wrong lairColor',message:'Provided lairColor: "'+lairColor+'" is not Lair compliant'}} var hosts=Hosts.find({'projectId':projectId}).fetch() if(statusOption==='all'){hosts.forEach(function(host){changeHostColor(host._id,lairColor)}) count=hosts.length}else if(statusOption==='none'){hosts.forEach(function(host){var hostid=host._id var arrayLen=getServicesOrIssues(hostid).length if(arrayLen<=0){changeHostColor(hostid,lairColor) statCount++}}) count=statCount}else if(StatusMap.indexOf(statusOption)!==-1){hosts.forEach(function(host){var changeColor=!1 var hostid=host._id var obj=getServicesOrIssues(hostid) changeColor=(obj.length>0&&obj[0].status===statusOption&&obj.every(allSameColor)) if(changeColor){changeHostColor(hostid,lairColor) statCount++} count=statCount})}else if(statusOption==='same'){hosts.forEach(function(host){var changeColor=!1 var hostid=host._id var obj=getServicesOrIssues(hostid) changeColor=(obj.every(allSameColor)) if(changeColor){changeHostColor(hostid,lairColor) statCount++} count=statCount})}else if(statusOption==='diff'){hosts.forEach(function(host){var changeColor=!1 var hostid=host._id var obj=getServicesOrIssues(hostid) changeColor=!(obj.every(allSameColor)) if(changeColor){changeHostColor(hostid,lairColor) statCount++} count=statCount})}else{throw{name:'Incorrect statusOption Selection',message:'Incorrect statusOption selection: "'+statusOption+'" is not a valid statusOption for this function'}} console.log('Total of '+count+' host(s) updated')} function changeServicesRegexToSpecifiedColor(lairServiceRegex,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address if(lairColor!=='lair-grey'&&lairColor!=='lair-blue'&&lairColor!=='lair-green'&&lairColor!=='lair-orange'&&lairColor!=='lair-red'){console.log('Invalid color specified') return} var services=Services.find({'projectId':projectId,'service':{'$regex':lairServiceRegex}}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){Services.update({'_id':service._id},{$set:{'status':lairColor,'lastModifiedBy':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated to '+lairColor+'.')} function changeServicesToColorByPort(lairPort,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address if(lairColor!=='lair-grey'&&lairColor!=='lair-blue'&&lairColor!=='lair-green'&&lairColor!=='lair-orange'&&lairColor!=='lair-red'){console.log('Invalid color specified') return} var services=Services.find({'projectId':projectId,'port':lairPort}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){Services.update({'_id':service._id},{$set:{'status':lairColor,'last_modifiedBy':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated to '+lairColor+'.')} function changeServicesToSpecifiedColor(lairService,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address if(lairColor!=='lair-grey'&&lairColor!=='lair-blue'&&lairColor!=='lair-green'&&lairColor!=='lair-orange'&&lairColor!=='lair-red'){console.log('Invalid color specified') return} var services=Services.find({'projectId':projectId,'service':lairService}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){Services.update({'_id':service._id},{$set:{'status':lairColor,'last_modifiedBy':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated to '+lairColor+'.')} function changeServicesToSpecifiedColorByProduct(lairServiceProduct,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address if(lairColor!=='lair-grey'&&lairColor!=='lair-blue'&&lairColor!=='lair-green'&&lairColor!=='lair-orange'&&lairColor!=='lair-red'){console.log('Invalid color specified') return} var services=Services.find({'projectId':projectId,'product':lairServiceProduct}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){Services.update({'_id':service._id},{$set:{'status':lairColor,'last_modifiedBy':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated to '+lairColor+'.')} function changeServicesToSpecifiedColor(lairPort,lairColor){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address if(lairColor!=='lair-grey'&&lairColor!=='lair-blue'&&lairColor!=='lair-green'&&lairColor!=='lair-orange'&&lairColor!=='lair-red'){console.log('Invalid color specified') return} var services=Services.find({'projectId':projectId,'service':lairPort}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){console.log('Updating: '+service.service+'/'+service.protocol) Services.update({'_id':service._id},{$set:{'status':lairColor,'last_modified_by':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated')} function countHostServicesBycolor(color){var hosts={} var projectId=Session.get('projectId') if(StatusMap.indexOf(color)===-1){console.log('Lair Supserviceed colors: '+StatusMap) throw{name:'Wrong color',message:'Provided color: "'+color+'" is not Lair compliant'}} var services=Services.find({'projectId':projectId,'status':color}).fetch() services.forEach(function(service){host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) if(hosts.hasOwnProperty(host.ipv4)){hosts[host.ipv4]++}else{hosts[host.ipv4]=1}}) for(var host in hosts){console.log(host+' ('+hosts[host]+')')}} function countHostServicesBycolor(color){var hosts={} var projectId=Session.get('projectId') if(StatusMap.indexOf(color)===-1){console.log('Lair Supserviceed colors: '+StatusMap) throw{name:'Wrong color',message:'Provided color: "'+color+'" is not Lair compliant'}} var services=Services.find({'projectId':projectId,'status':color}).fetch() services.forEach(function(service){host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) if(hosts.hasOwnProperty(host.ipv4)){hosts[host.ipv4]++}else{hosts[host.ipv4]=1}}) for(var host in hosts){console.log(host+' ('+hosts[host]+')')}} function deleteHostServicesByTool(ipAddr,lastModBy){var projectId=Session.get('projectId') var host=Hosts.findOne({'projectId':projectId,'ipv4':ipAddr}) if(typeof host==='undefined'){console.log('No matching host found') return} var services=Services.find({'projectId':projectId,'hostId':host._id,'lastModifiedBY':lastModBy}).fetch() if(services.length<1){console.log('No matching Services found')} services.forEach(function(service){console.log('Removing '+service.protocol+'/'+service.service) Meteor.call('removeService',projectId,service._id,function(){})}) console.log('Total of '+services.length+' service(s) removed.')} function deleteHostsByCIDR(){var hostTargets=[] var projectId=Session.get('projectId') var nets=Array.prototype.slice.call(arguments,0) var hosts=Hosts.find({projectId:projectId}).fetch() var hostip={} var hostid={} var count=0 function dec2Bin(octet,cidr){var pad='00000000' var bin=parseInt(octet[0],10).toString(2) var bincidr=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin) for(var i=1;i<=octet.length;i++){bin=parseInt(octet[i],10).toString(2) bincidr+=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin)} return bincidr.slice(0,parseInt(cidr,10))} hosts.forEach((host){var ip=host.ipv4.split('.') hostip[dec2Bin(ip,32)]=host.ipv4 hostid[host.ipv4]=host._id}) nets.forEach(function(cidr){cidr=cidr.split('/') var net=cidr[0].split('.') var netbin=dec2Bin(net,cidr[1]) for(var key in hostip){if((key.slice(0,parseInt(cidr[1],10)))===netbin){Meteor.call('removeHost',projectId,hostid[hostip[key]],function(err){if(!err){Meteor.call('removeHostFromIssues',projectId,hostip[key])}}) count ++}} console.log('Total of '+count+' host(s) removed.')})} function deleteHostsByStatus(status){var projectId=Session.get('projectId') var hosts=Hosts.find({'projectId':projectId,'status':status}).fetch() if(hosts.length<1){console.log('No matching hosts found') return} hosts.forEach(function(host){console.log('Removing '+host.ipv4) Meteor.call('removeHost',projectId,host._id,function(err){if(!err){Meteor.call('removeHostFromIssues',projectId,host.ipv4)}})}) console.log('Total of '+hosts.length+' host(s) removed.')} function deleteIssuesByStatus(status){var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId,'status':status}).fetch() if(issues.length<1){console.log('No matching Issues found') return} issues.forEach(function(issue){console.log('Removing '+issue.title) Meteor.call('removeIssue',projectId,issue._id)}) console.log('Total of '+issues.length+' Issue(s) removed.')} function deleteIssuesWithNoHosts(){var projectId=Session.get('projectId') var orphanedIssues=Issues.find({'projectId':projectId,'hosts':{$size:0}}).fetch() if(orphanedIssues.length<1){console.log('No orphaned issues present') return} orphanedIssues.forEach(function(issue){console.log('Removing: '+issue.title) Meteor.call('removeIssue',projectId,issue._id,function(){})}) console.log('Total of '+orphanedIssues.length+' vuln(s) removed')} function deleteServices(port,protocol,service){var projectId=Session.get('projectId') var services=Services.find({'projectId':projectId,'port':port,'protocol':protocol,'service':service}) services.forEach(function(service){console.log('Removing Service : '+service._id+' '+service.port+'/'+service.protocol+' '+service.service) Meteor.call('removeService',projectId,service.hostId,service._id)})} function dumpIssueEvidence(){var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId}).fetch() issues.forEach(function(issue){console.log(issue.title) console.log(issue.evidence)})} function dumpServiceNotes(noteRegex,ip){var projectId=Session.get('projectId') var re=new RegExp(noteRegex,'i') var services=Services.find({'projectId':projectId,'notes':{$elemMatch:{'title':{$regex:noteRegex,$options:'i'}}}},{notes:1,hostId:1}).fetch() var hostIds=_.pluck(services,'hostId') var hosts=Hosts.find({'_id':{$in:hostIds}},{sort:{longIpv4Addr:1},ipv4:1}).fetch() hosts.forEach(function(host){if(ip!==''&&ip!==host.ipv4){return} services=Services.find({'hostId':host._id},{sort:{service:1},notes:1,service:1,protocol:1}).fetch() services.forEach(function(service){service.notes.forEach(function(note){if(re.test(note.title)){console.log(host.ipv4+':'+service.port+'/'+service.protocol+' - '+note.title+'\n'+note.content)}})})})} function filterHostsNoServices(){} function findNoteByRegex(noteRegex,noteType){var projectId=Session.get('projectId') var noteRe=new RegExp(noteRegex,'i') if(noteType==='project'||noteType==='all'){console.log('Project Notes') var curProj=Projects.findOne({'_id':projectId},{notes:1}) curProj.notes.forEach(function(note){if(noteRe.test(note.title)||noteRe.test(note.content)){console.log('\t'+note.title)}})} if(noteType==='host'||noteType==='all'){console.log('Host Notes') Hosts.find({'projectId':projectId,$or:[{'notes':{$elemMatch:{'title':{$regex:noteRegex,$options:'i'}}}},{'notes':{$elemMatch:{'content':{$regex:noteRegex,$options:'i'}}}}]},{notes:1}).fetch().forEach(function(host){host.notes.forEach(function(note){if(noteRe.test(note.title)||noteRe.test(note.content)){console.log('\t'+host.ipv4+' -> '+note.title)}})})} if(noteType==='service'||noteType==='all'){console.log('Service Notes') Services.find({'projectId':projectId,$or:[{'notes':{$elemMatch:{'title':{$regex:noteRegex,$options:'i'}}}},{'notes':{$elemMatch:{'content':{$regex:noteRegex,$options:'i'}}}}]},{notes:1}).fetch().forEach(function(service){service.notes.forEach(function(note){if(noteRe.test(note.title)||noteRe.test(note.content)){var serviceHost=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) console.log('\t'+serviceHost.ipv4+' -> '+service.service.toString()+' -> '+note.title)}})})} if(noteType==='Issue'||noteType==='all'){console.log('Issue Notes') Issues.find({'projectId':projectId,$or:[{'evidence':{$regex:noteRegex,$options:'i'}},{'notes':{$elemMatch:{'title':{$regex:noteRegex,$options:'i'}}}},{'notes':{$elemMatch:{'content':{$regex:noteRegex,$options:'i'}}}}]},{notes:1}).fetch().forEach(function(vuln){if(noteRe.test(vuln.evidence)){console.log('\t'+vuln.title+' -> Evidence Field')} vuln.notes.forEach(function(note){if(noteRe.test(note.title)||noteRe.test(note.content)){console.log('\t'+vuln.title+' -> '+note.title)}})})}} function generateIssueBulkListByRegex(re){var projectId=Session.get('projectId') var services=Services.find({'projectId':projectId,'service':{'$regex':re}}).fetch() var entries=[] services.forEach(function(service){var host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) entries.push(host.ipv4+","+service.port+","+service.protocol)}) console.log(entries.join('\n'))} function generatePortStringFromService(service){var projectId=Session.get('projectId') var query={'projectId':projectId,'service':service} var services=Services.find(query).fetch() return _.uniq(_.pluck(services,'port')).sort(function(a,b){return a-b}).join(',')} function generateUniquePortString(protocol){var projectId=Session.get('projectId') var query={'projectId':projectId} if(typeof protocol!=='undefined'){query.protocol=protocol} var services=Services.find(query).fetch() return _.uniq(_.pluck(services,'port')).sort(function(a,b){return a-b}).join(',')} function generateURLList(){var projectId=Session.get('projectId') var q={'projectId':projectId} var hosts=Hosts.find(q).fetch() if(!hosts){console.log('No hosts found') return} var c=0 var urls=[] hosts.forEach(function(host){var names=host.hostnames var hostId=host._id var query={'projectId':projectId,'hostId':hostId} query.service={'$regex':'web|www|ssl|http|https','$options':'i'} var services=Services.find(query).fetch() services.forEach(function(service){var protocol='http://' if(service.service.match(/(ssl|https)/gi)){protocol='https://'} c++ urls.push(protocol+host.ipv4+':'+service.port) names.forEach(function(n){c++ urls.push(protocol+n+':'+service.port)})})}) console.log(urls.join('\n')) console.log(c+' URL(s) generated')} function generateWebDiscoTargetList(){var projectId=Session.get('projectId') var q={'projectId':projectId} var hosts=Hosts.find(q).fetch() if(hosts.length<1){console.log('No hosts found') return} var c=0 hosts.forEach(function(host){var names=host.hostnames var hostId=host._id var query={'projectId':projectId,'hostId':hostId} query.service={'$regex':'web|www|ssl|http|https','$options':'i'} var services=Services.find(query).fetch() var urls=[] services.forEach(function(service){var protocol='http' if(service.service.match(/(ssl|https)/g)){protocol='https'} service.notes.forEach(function(note){if(note.content.match(/SSL/)){protocol='https'}}) c++ urls.push(protocol+','+host.ipv4+','+service.port+',') names.forEach(function(n){c++ urls.push(protocol+','+host.ipv4+','+service.port+','+n)})})}) console.log(urls.join('\n')) console.log(c+' URL(s) generated')} function getHostsByCIDR(){var hostTargets=[] var nets=Array.prototype.slice.call(arguments,0) var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() var hostip={} function dec2Bin(octet,cidr){var pad='00000000' var bin=parseInt(octet[0],10).toString(2) var bincidr=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin) for(var i=1;i<=octet.length;i++){bin=parseInt(octet[i],10).toString(2) bincidr+=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin)} return bincidr.slice(0,parseInt(cidr,10))} hosts.forEach(function(host){var ip=host.ipv4.split('.') hostip[dec2Bin(ip,32)]=host.ipv4}) nets.forEach(function(cidr){cidr=cidr.split('/') var net=cidr[0].split('.') var netbin=dec2Bin(net,cidr[1]) for(var key in hostip){if((key.slice(0,parseInt(cidr[1],10)))===netbin){console.log(hostip[key])}}})} function getPersonByDepartmentRegex(dep){if(dep&&typeof dep!=='object'){return console.log('Department regex can not be a string, must be an object')} var projectId=Session.get('projectId') var people=People.find({projectId:projectId,department:{$regex:dep}}).fetch() people.forEach(function(p){console.log("'"+p.principalName+"','"+p.department+"','"+p.emails.join(" ")+"'")}) console.log("returned: "+people.len()+" results")} function getPersonEmail(){var projectId=Session.get('projectId') var people=People.find({projectId:projectId}).fetch() people.forEach(function(p){console.log("'"+p.principalName+"','"+p.department+"','"+p.emails.join(" ")+"'")}) console.log("returned: "+people.length+" results")} function greyServicesBlue(){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var services=Services.find({'projectId':projectId,'status':'lair-grey'}).fetch() if(services.length<1){console.log('No services found') return} services.forEach(function(service){Services.update({'_id':service._id},{$set:{'status':'lair-blue','last_modifiedBy':modifiedBy}})}) console.log('Total of '+services.length+' service(s) updated to lair-blue.')} function greyHostsNoServicesGreen(){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var hosts=Hosts.find({'projectId':projectId,'status':'lair-grey'}).fetch() if(typeof hosts==='undefined'||hosts.length===0){console.log('No hosts found') return} var c=0 hosts.forEach(function(host){var serviceCount=Services.find({'hostId':host._id,'port':{$gt:0}}).count() if(serviceCount===0){c++ console.log('Updating: '+host.ipv4) Hosts.update({'_id':host._id},{$set:{'status':'lair-green','last_modified_by':modifiedBy}})}}) console.log(c+' host(s) updated')} function hostnamesToNessus(){var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() var vhostTargets=[] hosts.forEach(function(host){var ip=host.ipv4 host.hostnames.forEach(function(name){var item=name+'['+ip+']' vhostTargets.push(item)})}) vhostTargets.forEach(function(item){console.log(item)})} function iisOsProfiler(){var projectId=Session.get('projectId') var weight=90 var tool='IIS OS Profiler' var services=Services.find({'projectId':projectId,'product':{'$regex':/IIS\s(httpd\s)?\d+\.\d+/,'$options':'i'}}).fetch() services.forEach(function(service){var product=service.product var res=product.match(/\d+\.\d+/) if(res===null){return} var version=parseFloat(res[0]) if(isNaN(version)){return} var os=Models.os() os.tool=tool os.weight=weight if(version<6){os.fingerprint='Microsoft Windows Server 2000'}else if(version<7){os.fingerprint='Microsoft Windows Server 2003'}else if(version<8){os.fingerprint='Microsoft Windows Server 2008'}else if(version<9){os.fingerprint='Microsoft Windows Server 2012'}else if(version<11){os.fingerprint='Microsoft Windows Server 2016'} if(os.fingerprint!==''){Meteor.call('setOs',projectId,service.hostId,os.tool,os.fingerprint,os.weight,function(err){if(err){console.log('Error generating OS for',service.hostId,err)}else{console.log('Created new OS',os.fingerprint,'for',service.hostId)}})}})} function listHostServicesBycolor(color){var projectId=Session.get('projectId') if(StatusMap.indexOf(color)===-1){console.log('Lair Supserviceed colors: '+StatusMap) throw{name:'Wrong color',message:'Provided color: "'+color+'" is not Lair compliant'}} var services=Services.find({'projectId':projectId,'status':color}).fetch() services.forEach(function(service){var host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) console.log(host.ipv4+':'+service.port+'/'+service.protocol)})} function listHostServicesByServiceRegex(serviceRegex){var REGEX=serviceRegex var projectId=Session.get('projectId') var serviceServices=Services.find({'projectId':projectId,'service':{'$regex':REGEX}}).fetch() if(serviceServices.length<1){console.log('No services found') return} serviceServices.forEach(function(service){var host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) console.log(host.ipv4+':'+service.port+'/'+service.protocol)})} function listHostsByIssueTitle(title){var projectId=Session.get('projectId') var issue=Issues.findOne({'projectId':projectId,'title':title}) var msfHostsOutput='' if(!issue){console.log('Issue not found') return} var hosts=issue.hosts hosts.forEach(function(host){console.log(host.ipv4+':'+host.port+'/'+host.protocol) msfHostsOutput+=host.ipv4+', '}) console.log('RHOSTS: '+msfHostsOutput.slice(0,-2))} function listHostsByIssueTitleRegex(issueRegex){var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId,'title':{'$regex':issueRegex}}).fetch() var msfHostsOutput='' if(issues.length<1){console.log('No issues found') return} issues.forEach(function(issue){console.log(issue.title) var hosts=issue.hosts hosts.forEach(function(host){console.log(host.ipv4+':'+host.port+'/'+host.protocol) msfHostsOutput+=host.ipv4+', '}) console.log('RHOSTS: '+msfHostsOutput.slice(0,-2)) msfHostsOutput=''})} function listHostByTag(tag){var hosts=Hosts.find({projectId:Session.get('projectId'),tags:tag}).fetch() hosts.forEach(function(host){console.log(host.ipv4)})} function listUnknownOpenServices(scope,outputFormat){var projectId=Session.get('projectId') var hostlist=[] var tcpservices=[] var udpservices=[] var hosts=Hosts.find({'projectId':projectId}).fetch() hosts.forEach(function(host){var services=Services.find({'projectId':projectId,'hostId':host._id}).fetch() services.forEach(function(service){if(service.port>0){if(scope==='product'){if(service.product.toLowerCase()==='unknown'){hostlist.push(host.ipv4) if(service.protocol==='tcp'){tcpservices.push(service.port)}else if(service.protocol==='udp'){udpservices.push(service.port)}}}else if(scope==='service'){if(service.service.toLowerCase()==='unknown'){hostlist.push(host.ipv4) if(service.protocol==='tcp'){tcpservices.push(service.port)}else if(service.protocol==='udp'){udpservices.push(service.port)}}}else if(scope==='both'){if(service.service.toLowerCase()==='unknown'||service.product.toLowerCase()==='unknown'){hostlist.push(host.ipv4) if(service.protocol==='tcp'){tcpservices.push(service.port)}else if(service.protocol==='udp'){udpservices.push(service.port)}}}}}) if(outputFormat==='nmap'){if(tcpservices.length>0&&udpservices.length>0){console.log('nmap -v -sV --version-all -sS -sU '+host.ipv4+' -p T:'+tcpservices.toString()+',U:'+udpservices.toString())}else if(tcpservices.length>0){console.log('nmap -v -sV --version-all -sS '+host.ipv4+' -p '+tcpservices.toString())}else if(udpservices.length>0){console.log('nmap -v -sV --version-all -sU '+host.ipv4+' -p '+udpservices.toString())} tcpservices=[] udpservices=[]} if(outputFormat==='hostAndPort'){if(tcpservices.length>0){tcpservices.forEach(function(tcpservice){console.log(host.ipv4+':'+tcpservice.toString())})} if(udpservices.length>0){udpservices.forEach(function(udpservice){console.log(host.ipv4+':'+udpservice.toString())})}}}) if((tcpservices.length>0||udpservices.length>0)&&outputFormat==='list'){var tcpservicesUniq=tcpservices.filter(function(elem,pos){return tcpservices.indexOf(elem)===pos}) var udpservicesUniq=udpservices.filter(function(elem,pos){return udpservices.indexOf(elem)===pos}) console.log('Hosts:') console.log(hostlist.toString()) console.log('TCP Services:') console.log(tcpservicesUniq.sort(function(a,b){return a-b}).toString()) console.log('UDP Services:') console.log(udpservicesUniq.sort(function(a,b){return a-b}).toString())}} function mergeDuplicateIssues(){var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId}).fetch() var sortedIssues=issues.sort((a,b)=>(a.title>b.title)?1:-1) var hosts=Hosts.find({'projectId':projectId}).fetch() for(var i=0;i<sortedIssues.length-1;i++){source=sortedIssues[i+1] dest=sortedIssues[i] if(source.title==dest.title&&source.cvss==dest.cvss){console.log("found match: "+dest.title) console.log(source.hosts.length+" hosts to move.") source.notes.forEach(function(note){console.log("Adding Note") Meteor.call('addIssueNote',projectId,dest._id,note.title,note.content)}) source.hosts.forEach(function(host){hosts.forEach(function(projectHost){var serviceMatch=Services.findOne({'projectId':projectId,'hostId':projectHost._id,'port':host.port,'protocol':host.protocol}) if(projectHost.ipv4==host.ipv4&&serviceMatch!=null){console.log("Added "+host.ipv4+" to "+dest.title) Meteor.call('removeHostFromIssue',projectId,source._id,host.ipv4,host.port,host.protocol) Meteor.call('addHostToIssue',projectId,dest._id,host.ipv4,host.port,host.protocol)}})}) source.cves.forEach(function(cve){if(!dest.cves.includes(cve)){console.log("Adding CVE "+cve) Meteor.call('addCVE',projectId,dest._id,cve)}}) if(source.evidence!=dest.evidence){dest.evidence+="\n\n"+source.evidence console.log("Updating Evidence.") Meteor.call('setIssueEvidence',projectId,dest._id,dest.evidence)} console.log("Removing issue.") Meteor.call('removeIssue',projectId,source._id)}}} function mergeIssues(titleRegex,minCVSS,maxCVSS,hostsRegex,newTitle,newCVSS,update){if(typeof titleRegex!=='object'){return console.log('Issue regex can not be a string, must be a object')} if(typeof newTitle!=='string'){return console.log('Invalid title')} if(typeof newCVSS!=='string'){return console.log('Invalid cvss. Variable must be a string')} var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId,'title':{'$regex':titleRegex},'cvss':{'$gte':minCVSS,'$lte':maxCVSS},'hosts.ipv4':{'$regex':hostsRegex}}).fetch() if(issues.length<1){return console.log('Did not find any issues with the given regex')} var highestCVSS=0 issues.sort(sortByCVSS) issues.forEach(function(Issue){console.log('CVSS: '+Issue.cvss+' - Hosts: '+Issue.hosts.length+' - Title: '+Issue.title) if(Issue.cvss>highestCVSS){highestCVSS=Issue.cvss}}) console.log('Total found: '+issues.length+' Highest CVSS: '+highestCVSS) if(update){if(newCVSS==='max'){newCVSS=highestCVSS} var existingIssue=Issues.findOne({'projectId':projectId,'title':newTitle}) if(typeof existingIssue!=='undefined'){issues.push(existingIssue) Meteor.call('removeIssue',projectId,existingIssue._id)} console.log('Going to merge '+issues.length+' issues') var newDescription='' var newSolution='' var newEvidence='' var newNotes=[] var newReferences=[] var cves=[] var hostList=[] var newFiles=[] issues.forEach(function(Issue){newDescription=newDescription+'CVSS: '+Issue.cvss+' - Hosts: '+Issue.hosts.length+' - Title: '+Issue.title+"\n" newSolution='' newEvidence='' newReferences=newReferences.concat(Issue.references) newNotes=newNotes.concat(Issue.notes) cves=cves.concat(Issue.cves) hostList=hostList.concat(Issue.hosts) newFiles=newFiles.concat(Issue.files)}) var newHostList=unique(hostList) var newCVEs=unique(cves) Meteor.call('createIssue',projectId,newTitle,newCVSS,newDescription,newEvidence,newSolution,function(err,res){if(err){console.log('Error: could not create new Issue',err.message) if(existingIssue){console.log('Looks like you lost',existingIssue.title)}}else{addExistingContentToIssue(res)}}) return console.log('Complete')} function sortByHostCount(a,b){if(a.hosts.length>b.hosts.length){return-1} if(a.hosts.length<b.hosts.length){return 1} return 0} function sortByTitle(a,b){if(a.hosts.title>b.hosts.title){return-1} if(a.hosts.title<b.hosts.title){return 1} return 0} function sortByCVSS(a,b){if(a.cvss>b.cvss){return-1} if(a.cvss<b.cvss){return 1} return 0} function addExistingContentToIssue(issueId){newNotes.forEach(function(note){Meteor.call('addIssueNote',projectId,issueId,note.title,note.content)}) newHostList.forEach(function(host){Meteor.call('addHostToIssue',projectId,issueId,host.ipv4,host.port,host.protocol)}) newCVEs.forEach(function(cve){Meteor.call('addCVE',projectId,issueId,cve)}) newReferences.forEach(function(ref){Meteor.call('addReference',projectId,issueId,ref.link,ref.name)}) removeIssues()} function removeIssues(){console.log('Removing Issues') issues.forEach(function(Issue){Meteor.call('removeIssue',projectId,Issue._id)})} function unique(arr){var hash={} var result=[] for(var i=0,l=arr.length;i<l;++i){var objString=JSON.stringify(arr[i]) if(!hash.hasOwnProperty(objString)){hash[objString]=!0 result.push(arr[i])}} return result}} function getHostList(Issue){var hosts='';for(var i=0;i<Issue.hosts.length;i++){hosts+=Issue.hosts[i].ipv4+','} return hosts+'\n'} function mergeIssuesByTitle(issueRegex,newTitle,cvss){if(typeof issueRegex!=='object'){return console.log('Issue regex can not be a string, must be a object')} if(typeof newTitle!=='string'){return console.log('Invalid title')} if(typeof cvss!=='number'){return console.log('Invalid cvss. Variable must be a number')} var projectId=Session.get('projectId') var issues=Issues.find({'projectId':projectId,'title':{'$regex':issueRegex}}).fetch() if(issues.length<1){return console.log('Did not find any issues with the given regex')} var existingVenerability=Issues.findOne({'projectId':projectId,'title':newTitle}) if(typeof existingVenerability!=='undefined'){issues.push(existingVenerability) Meteor.call('removeIssue',projectId,existingVenerability._id)} console.log('Going to merge '+issues.length+' issues') var newDescription='' var newSolution='' var newEvidence='' var newNotes=[] var cves=[] var hostList=[] issues.forEach(function(Issue){issue_hosts=getHostList(Issue);newDescription+='\n\n'+'From '+Issue.title+'\n'+'Affected Hosts: '+issue_hosts+Issue.description;newSolution+='\n\n'+'From '+Issue.title+'\n'+'Affected Hosts: '+issue_hosts+Issue.solution;newEvidence+='\n\n'+'From '+Issue.title+'\n'+'Affected Hosts: '+issue_hosts+Issue.evidence;newNotes=newNotes.concat(Issue.notes) cves=cves.concat(Issue.cves) hostList=hostList.concat(Issue.hosts)}) var newHostList=unique(hostList) var newCVEs=unique(cves) Meteor.call('createIssue',projectId,newTitle,cvss,newDescription,newEvidence,newSolution,function(err,res){if(err){console.log('Error: could not create new Issue',err.message) if(existingVenerability){console.log('Looks like you lost',existingVenerability.title)}}else{addExistingContentToVenerability(res)}}) return console.log('Complete') function addExistingContentToVenerability(IssueId){newNotes.forEach(function(note){Meteor.call('addIssueNote',projectId,IssueId,note.title,note.content)}) newHostList.forEach(function(host){Meteor.call('addHostToIssue',projectId,IssueId,host.ipv4,host.port,host.protocol)}) newCVEs.forEach(function(cve){Meteor.call('addCVE',projectId,IssueId,cve)}) removeIssues()} function removeIssues(){issues.forEach(function(Issue){Meteor.call('removeIssue',projectId,Issue._id)})} function unique(arr){var hash={} var result=[] for(var i=0,l=arr.length;i<l;++i){var objString=JSON.stringify(arr[i]) if(!hash.hasOwnProperty(objString)){hash[objString]=!0 result.push(arr[i])}} return result}} function negateHostsByCIDR(){var nets=Array.prototype.slice.call(arguments,0) var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() var hostip={} function dec2Bin(octet,cidr){var pad='00000000' var bin=parseInt(octet[0],10).toString(2) var bincidr=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin) for(var i=1;i<=octet.length;i++){bin=parseInt(octet[i],10).toString(2) bincidr+=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin)} return bincidr.slice(0,parseInt(cidr,10))} hosts.forEach(function(host){var ip=host.ipv4.split('.') hostip[dec2Bin(ip,32)]=host.ipv4}) nets.forEach(function(cidr){cidr=cidr.split('/') var net=cidr[0].split('.') var netbin=dec2Bin(net,cidr[1]) for(var key in hostip){if((key.slice(0,parseInt(cidr[1],10)))===netbin){delete hostip[key]}}}) for(var key in hostip){console.log(hostip[key])}} function niktoHostList(services,domain){if(domain&&typeof domain!=='object'){return console.log('Domain regex can not be a string, must be an object')} var HostTargets={} var projectId=Session.get('projectId') function getHosts(lpid,port){var host=Hosts.findOne({'projectId':projectId,'_id':lpid}) if(!(host.ipv4+':'+port in HostTargets)){HostTargets[host.ipv4+':'+port]=!0} if(domain){host.hostnames.forEach(function(hostname){if(domain.test(hostname)&&!(hostname+':'+port in HostTargets)){HostTargets[hostname+':'+port]=!0}})}} services.forEach(function(service){var foundServices=[] if(typeof service==='object'){foundServices=Services.find({'projectId':projectId,'service':{'$regex':service}}).fetch() foundServices.forEach(function(s){getHosts(s.hostId,s.port)})}else if(typeof service==='string'){var list=service.split('-') for(var i=parseInt(list[0],10);i<=parseInt(list[1],10);i++){foundServices=Services.find({'projectId':projectId,'service':i}).fetch() foundServices.forEach(function(s){getHosts(s.hostId,s.port)})}}else{var s=Services.findOne({'projectId':projectId,'service':service}) getHosts(s.hostId,service.port)}}) for(var key in HostTargets){console.log(key)}} function niktoTopFindings(custom,filter){var nikto=new RegExp('Nikto') var findings={} var projectId=Session.get('projectId') var topFindings=['(.*might be interesting.*)','(.*Public HTTP Methods:.*PUT.*)','(.*[Ww]eb[Dd]av.*)','(.*Directory indexing found.*)','(.*default file found.*)','(.*Server leaks.*IP.*)','(.*OSVDBID:.*)'] if(custom.length>0){topFindings=custom} var services=Services.find({'projectId':projectId}).fetch() services.forEach(function(service){var host=Hosts.findOne({'projectId':projectId,'_id':service.hostId}) service.notes.forEach(function(note){if(nikto.test(note.title)){var title=note.title.match(/\(.*\)/) if(filter){var search=new RegExp(topFindings.join('|')+'\\n','g') var f=note.content.match(search) if(f){if(!(findings[host.ipv4+' '+title])){findings[host.ipv4+' '+title]=[]} findings[host.ipv4+' '+title].push(f.join(''))}}else{console.log(host.ipv4+' '+title) console.log(note.content)}}})}) if(filter){for(var key in findings){console.log(key) console.log(findings[key].join(''))}}} function NormalizeProtocols(){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var services=Services.find({'projectId':projectId,}).fetch() if(services.length<1){console.log('No services found') return} var updated=0;services.forEach(function(service){if(service.protocol!=service.protocol.toLowerCase()){Services.update({'_id':service._id},{$set:{'protocol':service.protocol.toLowerCase(),'last_modifiedBy':modifiedBy}}) updated++}}) console.log('Total of '+updated+' service(s) updated.')} function NormalizeUnknownProducts(){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var services=Services.find({'projectId':projectId,}).fetch() if(services.length<1){console.log('No services found') return} var updated=0;services.forEach(function(service){if(service.product.toLowerCase()=='unknown'){Services.update({'_id':service._id},{$set:{'product':'','last_modifiedBy':modifiedBy}}) updated++}}) console.log('Total of '+updated+' service(s) updated.')} function removePort0ServicesNoReference(){var projectId=Session.get('projectId') var servicearray=[] var excludedarray=[] var delarray=[] var hosts=Hosts.find({'projectId':projectId}).fetch() hosts.forEach(function(host){var hostid=host._id var services=Services.find({'projectId':projectId,'hostId':host._id}).fetch() services.forEach(function(service){if(service.port<=0&&service.notes<1){var dict={ip:host.ipv4,service:service} servicearray.push(dict)}})}) var issues=Issues.find({'projectId':projectId}).fetch() issues.forEach(function(issue){issue.hosts.forEach(function(host){if(host.port!=0){return} for(var x=0;x<servicearray.length;x++){if(servicearray[x].ip==host.ipv4&&host.protocol==servicearray[x].service.protocol){excludedarray.push(servicearray[x].service._id)}}})}) for(var x=0;x<servicearray.length;x++){for(var y=0;y<excludedarray.length;y++){if(servicearray[x].service._id==excludedarray[y]){continue}} delarray.push(servicearray[x].service)} console.log("Removing "+delarray.length+" out of "+servicearray.length+" port 0 services") for(var x=0;x<delarray.length;x++){console.log('Removing ServiceID: '+delarray[x]._id) Meteor.call('removeService',projectId,delarray[x].hostId,delarray[x]._id,function(err){})}} function removeIPBasedHostnames(){var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() hosts.forEach(function(host){var ip=host.ipv4 var hostnames=[] host.hostnames.forEach(function(name){if(name.includes(ip)){console.log("removing "+name) return} if(name.includes(ip.replace(/\./g,"_"))){console.log("removing "+name) return} if(name.includes(ip.replace(/\./g,"-"))){console.log("removing "+name) return} var revIp=ip.split('.').reverse().join('.') if(name.includes(revIp)){console.log("removing "+name) return} if(name.includes(revIp.replace(/\./g,"_"))){console.log("removing "+name) return} if(name.includes(revIp.replace(/\./g,"-"))){console.log("removing "+name) return} hostnames.push(name)}) Hosts.update({_id:host._id},{$set:{'hostnames':hostnames,lastModifiedBy:Meteor.user().emails[0].address}})})} function removeHostnamesByPattern(pattern){var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() hosts.forEach(function(host){var hostnames=[] host.hostnames.forEach(function(name){if(name.includes(pattern)){console.log("removing "+name) return} hostnames.push(name)}) Hosts.update({_id:host._id},{$set:{'hostnames':hostnames,lastModifiedBy:Meteor.user().emails[0].address}})})} function searchServiceNoteContent(noteRegex,searchString){var projectId=Session.get('projectId') var re=new RegExp(noteRegex,'i') var search=new RegExp(searchString,'g') var ciphers=[] var services=Services.find({'projectId':projectId,'notes':{$elemMatch:{'title':{$regex:noteRegex,$options:'i'}}}},{notes:1,hostId:1}).fetch() function unique(arr){var u={},a=[];for(var i=0,l=arr.length;i<l;++i){if(!u.hasOwnProperty(arr[i])){a.push(arr[i]);u[arr[i]]=1}} return a} services.forEach(function(service){service.notes.forEach(function(note){if(re.test(note.title)){ciphers.push.apply(ciphers,note.content.match(search))}})}) console.log(unique(ciphers).join("\n"))} function servicesToColorByHosts(hosts,port,color){var projectId=Session.get('projectId') var modifiedBy=Meteor.user().emails[0].address var count=0 var status={'lair-red':4,'lair-orange':3,'lair-blue':2,'lair-green':0,'lair-grey':0} if(StatusMap.indexOf(color)===-1){console.log('Lair Supserviceed colors: '+StatusMap) throw{name:'Wrong Color',message:'Provided color: "'+color+'" is not Lair compliant'}} hosts.forEach(function(target){var host=Hosts.findOne({projectId:projectId,'ipv4':target}) var hostServices=Services.find({'hostId':host._id,'port':port}).fetch() if(hostServices.length<1){return} hostServices.forEach(function(service){console.log('Updating: '+target+':'+service.port+'/'+service.protocol) Meteor.call('setPortStatus',projectId,service._id,color) if(status[color]>status[host.status]){console.log('Updating: '+target+' status "'+color+'"') Meteor.call('setHostStatus',projectId,host._id,color)} count++})}) console.log(count+' service(s) updated')} function setGlobalServiceByPort(port,protocol,service){var projectId=Session.get('projectId') var services=Services.find({'projectId':projectId,'port':port,'protocol':protocol,'service':{'$ne':service}}) services.forEach(function(s){Meteor.call('setServiceService',projectId,s._id,service,function(err){if(!err){console.log('Modified service successfully')}})})} function setHostOsByOsRegex(osRegex,newOs,weight){var projectId=Session.get('projectId') var query={'projectId':projectId,'os.fingerprint':{$regex:osRegex}} var hosts=Hosts.find(query).fetch() if(hosts.length<1){console.log('No hosts found') return} hosts.forEach(function(host){Meteor.call('setOs',projectId,host._id,'Manual',newOs,weight,function(err){if(err){console.log('Unable to update host '+host.ipv4) return} console.log('Updated host '+host.ipv4)})})} function setHostServiceByPort(host,port,protocol,service){var projectId=Session.get('projectId') var host=Hosts.findOne({'projectId':projectId,'ipv4':host,}) var services=Services.find({'projectId':projectId,'hostId':host._id,'port':{'$in':port},'protocol':protocol,'service':{'$ne':service}}) services.forEach(function(s){Meteor.call('setServiceService',projectId,s._id,service,function(err){if(!err){console.log('Modified service successfully')}})})} function tagHostsByCIDR(tag,net){var hostTargets=[] var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() var hostip={} function addHostTag(hostId,tag){check(hostId,Matchers.isObjectId) check(tag,Matchers.isNonEmptyString) return Hosts.update({_id:hostId},{$addToSet:{tags:tag},$set:{lastModifiedBy:Meteor.user().emails[0].address}})} function dec2Bin(octet,cidr){var pad='00000000' var bin=parseInt(octet[0],10).toString(2) var bincidr=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin) for(var i=1;i<=octet.length;i++){bin=parseInt(octet[i],10).toString(2) bincidr+=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin)} return bincidr.slice(0,parseInt(cidr,10))} hosts.forEach(function(host){var ip=host.ipv4.split('.') hostip[dec2Bin(ip,32)]=host}) cidr=net.split('/') var net=cidr[0].split('.') var netbin=dec2Bin(net,cidr[1]) for(var key in hostip){if((key.slice(0,parseInt(cidr[1],10)))===netbin){addHostTag(hostip[key]._id,tag) console.log(hostip[key]._id,tag)}}} function uniqueServicesByHostsCIDR(){var hostTargets=[] var projectId=Session.get('projectId') var nets=Array.prototype.slice.call(arguments,0) var hosts=Hosts.find({projectId:projectId}).fetch() var hostip={} var hostid={} var ids=[] function dec2Bin(octet,cidr){var pad='00000000' var bin=parseInt(octet[0],10).toString(2) var bincidr=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin) for(var i=1;i<=octet.length;i++){bin=parseInt(octet[i],10).toString(2) bincidr+=(bin.length>=pad.length?bin:pad.slice(0,pad.length-bin.length)+bin)} return bincidr.slice(0,parseInt(cidr,10))} hosts.forEach(function(host){var ip=host.ipv4.split('.') hostip[dec2Bin(ip,32)]=host.ipv4 hostid[host.ipv4]=host._id}) nets.forEach(function(cidr){cidr=cidr.split('/') var net=cidr[0].split('.') var netbin=dec2Bin(net,cidr[1]) for(var key in hostip){if((key.slice(0,parseInt(cidr[1],10)))===netbin){ids.push(hostid[hostip[key]])}}}) var services=Services.find({projectId:projectId,hostId:{$in:ids}}).fetch() return _.uniq(_.pluck(services,'port')).sort(function(a,b){return a-b}).join(',')} function replaceNessusWithOptiv(){const searchRegExp='Nessus';const replaceWith='Optiv';var projectId=Session.get('projectId') var issues=Issues.find({projectId,projectId}).fetch() issues.forEach(function(issue){console.log("Updating evidence verbiage: Nessus -> Optiv") console.log(issue.title) console.log(issue.evidence.replace(searchRegExp,replaceWith)) Meteor.call('setIssueEvidence',projectId,issue._id,issue.evidence.replace(searchRegExp,replaceWith))})} function dangerousServices(){var projectId=Session.get('projectId') var ports=Services.find({'projectId':projectId}) var serverMap={0:'NULL',21:'FTP',25:'SMTP',53:'DNS',80:'HTTP',81:'HTTP',443:'HTTPS',500:'ISAKMP',} var protoMap={'www':'HTTP','http':'HTTP','https':'HTTPS','ssl':'HTTPS','isakmp':'ISAKMP','ftp':'FTP','domain':'DNS','dns':'DNS'} ports.forEach(function(port){if(!serverMap[port.port]&&!protoMap[port.service]){var host=Hosts.findOne({'projectId':projectId,'_id':port.hostId}) console.log(host.ipv4+","+port.port+","+port.protocol)}})} function normalizeServices(){var projectId=Session.get('projectId') var ports=Services.find({'projectId':projectId}) var serverMap={22:'SSH',21:'FTP',23:'TELNET',25:'SMTP',53:'DNS',79:'FINGER',80:'HTTP',81:'HTTP',111:'RPC',123:'NTP',135:'MS-RPC',137:'NETBIOS',139:'CIFS',161:'SNMP',443:'HTTPS',445:'CIFS',500:'ISAKMP',1433:'MS-SQL-TDS',1434:'MS-SQL-MONITOR',2222:'SSH',2638:'SYBASE',3389:'MS RDP',4786:'SMARTINSTALL',5060:'SIP',5222:'XMPPCLIENT',7777:'HTTP',8000:'HTTP',8080:'HTTP',8081:'HTTP',8443:'HTTPS',9090:'HTTP',49316:'MS-SQL-TDS'} ports.forEach(function(port){var service=port.service.toUpperCase() var mappedService=serverMap[port.port] if(mappedService){service=mappedService} if(service===''){service='UNKNOWN'} service=service.replace('WWW','HTTP') service=service.replace('HTTP-ALT','HTTP') service=service.replace('HTTPS-ALT','HTTPS') service=service.replace(/\?/g,'') if(service===port.service){return} Meteor.call('setServiceService',projectId,port._id,service,function(err){if(!err){console.log('Modified service')}else{console.log(err)}})})} function generateMAClist(){var hosts=Hosts.find({projectId:Session.get('projectId')}).fetch() var macstring=[] hosts.forEach(function(host){var ip=host.ipv4 var mac=host.mac host.hostnames.forEach(function(name){var item=ip+','+mac macstring.push(item)})}) macstring.forEach(function(item){console.log(item)})}
